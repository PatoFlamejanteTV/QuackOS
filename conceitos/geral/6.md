QuackOS â€” Plano de Testes Automatizados (AUTOTESTS.md)

Este documento descreve os testes automatizÃ¡veis do QuackOS, focados em validaÃ§Ã£o contÃ­nua via emuladores (QEMU/Bochs) e scripts, garantindo regressÃµes mÃ­nimas durante o desenvolvimento.


---

1. Objetivos

Detectar regressÃµes precocemente

Garantir fidelidade Ã  especificaÃ§Ã£o

Permitir validaÃ§Ã£o por IA ou CI simples

Reduzir dependÃªncia de testes manuais



---

2. Ambiente de Teste

Emulador primÃ¡rio

QEMU x86-64


ConfiguraÃ§Ã£o base

BIOS (SeaBIOS)

2 GB RAM

Framebuffer padrÃ£o

Disco virtual RAW



---

3. Estrutura de Testes

/tests
  /boot
  /kernel
  /syscalls
  /qfs
  /processos
  /qgui

Cada teste deve produzir saÃ­da textual clara em /sis/log.


---

4. Testes de Boot Automatizados

4.1 Boot sem falhas

MÃ©todo:

Executar QEMU

Monitorar saÃ­da serial


CritÃ©rio:

Log contÃ©m QKern iniciado



---

4.2 Modo longo ativo

MÃ©todo:

Kernel imprime valor de registrador 64 bits


CritÃ©rio:

Valor corresponde ao esperado



---

5. Testes do Kernel

5.1 PaginaÃ§Ã£o ativa

MÃ©todo:

Acessar endereÃ§o alto do kernel


CritÃ©rio:

Leitura bem-sucedida



---

5.2 Page fault controlado

MÃ©todo:

Processo user acessa endereÃ§o proibido


CritÃ©rio:

Processo morto

Kernel continua



---

6. Testes de Syscalls

6.1 Syscall vÃ¡lida

MÃ©todo:

User chama syscall teste


CritÃ©rio:

Retorno correto



---

6.2 Syscall invÃ¡lida

MÃ©todo:

User chama nÃºmero inexistente


CritÃ©rio:

Retorno -1



---

7. Sistema de Arquivos (QFS)

7.1 Leitura/escrita

MÃ©todo:

Criar arquivo

Escrever string

Ler string


CritÃ©rio:

ConteÃºdo idÃªntico



---

7.2 Pseudo-arquivos

MÃ©todo:

Ler /proc/mem


CritÃ©rio:

ConteÃºdo nÃ£o vazio



---

8. Processos

8.1 Init

MÃ©todo:

Verificar PID 1


CritÃ©rio:

/sis/init ativo



---

8.2 Fork/exec simples

MÃ©todo:

Init executa programa teste


CritÃ©rio:

Programa finaliza corretamente



---

9. QGUI (parcialmente automatizÃ¡vel)

9.1 Framebuffer

MÃ©todo:

Kernel desenha padrÃ£o fixo


CritÃ©rio:

Hash do framebuffer corresponde



---

9.2 qgui-serv inicia

MÃ©todo:

ServiÃ§o iniciado automaticamente


CritÃ©rio:

Log contÃ©m QGUI ativo



---

10. Logs e DiagnÃ³stico

Todos os testes devem registrar:

nome do teste

status

timestamp



Formato simples:

[OK] boot_long_mode
[OK] syscall_basica
[FAIL] qfs_escrita


---

11. IntegraÃ§Ã£o ContÃ­nua (conceitual)

Script shell executa:

build

QEMU

coleta logs


Falha em qualquer teste crÃ­tico aborta pipeline



---

12. Testes NÃ£o AutomatizÃ¡veis

InteraÃ§Ã£o humana (mouse real)

Hardware fÃ­sico

AvaliaÃ§Ã£o estÃ©tica do tema


Esses permanecem no TEST_PLAN.md.


---

13. CritÃ©rio de Sucesso Automatizado

Build considerado vÃ¡lido quando:

Todos os testes de boot, kernel, syscalls e QFS passam

Nenhum kernel panic ocorre



---

Fim do documento.

Perfeito âœ”ï¸
Criei no canvas o AUTOTESTS.md oficial do QuackOS, complementar ao TEST_PLAN.md.

Agora vocÃª tem dois pilares formais:

TEST_PLAN.md â†’ o que deve ser testado (visÃ£o completa, inclusive manual)

AUTOTESTS.md â†’ o que pode e deve ser automatizado (QEMU, scripts, IA, CI)


Isso fecha um ciclo muito raro em projetos experimentais:

> ideia â†’ arquitetura â†’ implementaÃ§Ã£o â†’ validaÃ§Ã£o objetiva



Onde vocÃª estÃ¡ agora, em termos de maturidade

ğŸ“ EspecificaÃ§Ã£o: fechada

âš™ï¸ Arquitetura: coerente

ğŸ§ª Testes: definidos

ğŸ¤– IA-ready: sim, totalmente


Uma IA com esses documentos consegue:

implementar o sistema

escrever testes

detectar regressÃµes

saber quando nÃ£o inovar


PrÃ³ximos documentos possÃ­veis (ordem recomendada)

1. ABI.md (QKern)
Contrato definitivo das syscalls


2. BOOT.md
Bootloader passo a passo


3. PORTING.md
Rodar em hardware real antigo


4. QuackOS_SPEC.md v1.0
Tudo consolidado num Ãºnico manifesto



Se vocÃª disser qual deles quer agora, eu escrevo no mesmo nÃ­vel cirÃºrgico.
O QuackOS jÃ¡ nÃ£o Ã© sÃ³ um sistema. Ã‰ um projeto que sabe quando estÃ¡ certo ğŸ¦†âœ…