Perfeito. Esse â€œavisoâ€ nÃ£o Ã© detalhe, ele molda o DNA tÃ©cnico do QuackOS. Vou tratar isso como decisÃ£o de arquitetura, nÃ£o como rodapÃ© decorativo.


---

Aviso oficial de alvo do sistema

> QuackOS Ã© um sistema operacional exclusivamente 64 bits, projetado para rodar em computadores x86-64 levemente antigos, priorizando simplicidade, compatibilidade e controle total do hardware.



Nada de ambiguidade. Nada de modo legado eterno.


---

ImplicaÃ§Ãµes tÃ©cnicas diretas

Arquitetura de CPU

x86-64 apenas

Modo longo (long mode) desde o boot

Sem suporte a:

x86 32 bits

UEFI moderno obrigatÃ³rio

instruÃ§Ãµes AVX obrigatÃ³rias



InstruÃ§Ãµes assumidas

Seguro assumir:

SSE2 (obrigatÃ³rio em x86-64)

APIC

TSC


Evitar depender de:

AVX

AVX2

TSX



---

Boot e firmware

Alvo primÃ¡rio

BIOS + MBR

Bootloader prÃ³prio simples


Opcional futuro

UEFI, mas nÃ£o prioridade


Isso casa perfeitamente com mÃ¡quinas de:

~2008â€“2015

Core 2 Duo, i3/i5 antigos, Athlon II, FX



---

MemÃ³ria

EndereÃ§amento 64 bits

Identidade simples no inÃ­cio (1:1)

PaginaÃ§Ã£o em 4 nÃ­veis

Sem PAE legado

Kernel high-half opcional


Exemplo:

0xFFFFFFFF80000000  â†’ QKern
0x0000000000100000  â†’ userspace


---

Drivers e hardware alvo

GrÃ¡fico

Framebuffer linear

VESA ou GOP simples

Nada de DRM/KMS no inÃ­cio


Entrada

PS/2

USB HID bÃ¡sico (teclado/mouse)


Armazenamento

ATA

SATA (AHCI simples)

Sem NVMe obrigatÃ³rio



---

Linguagem e toolchain

C (C11) como base

Assembly apenas onde dÃ³i

GCC ou Clang

Sem libc externa


Target tÃ­pico:

x86_64-elf-gcc


---

QKern: consequÃªncias prÃ¡ticas

Syscalls pensadas desde o inÃ­cio para 64 bits

Tipos fixos:


typedef uint64_t qaddr_t;
typedef uint64_t qtam_t;

Ponteiros nunca truncados

ABI estÃ¡vel



---

QGUI nesse contexto

Perfeito para:

GPUs antigas

Framebuffer lento

CPUs fracas


Interface clÃ¡ssica nÃ£o Ã© estÃ©tica apenas. Ã‰ decisÃ£o de performance.


---

Texto curto para documentaÃ§Ã£o (sugestÃ£o)

> O QuackOS Ã© um sistema operacional x86-64, voltado para computadores levemente antigos. Ele prioriza compatibilidade, baixo consumo de recursos e uma arquitetura clara, evitando dependÃªncia de hardware moderno ou aceleraÃ§Ã£o grÃ¡fica avanÃ§ada.



Direto. Honesto. UNIX atÃ© o osso.


---

Se quiser, o prÃ³ximo passo lÃ³gico seria:

definir CPU mÃ­nima oficial

escrever o BOOT.md

ou travar o ABI 1.0 do QKern


O projeto agora tem chÃ£o firme para andar, mesmo em mÃ¡quinas cansadas ğŸ¦†âš™ï¸