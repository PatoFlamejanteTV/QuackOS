Excelente. Testes s√£o onde o QuackOS deixa de ser conceito e vira m√°quina confi√°vel. Vou organizar isso como um plano de verifica√ß√£o em camadas, do el√©tron ao pato ü¶Üüîç
Tudo curto, mensur√°vel e alinhado ao esp√≠rito UNIX.


---

Plano de Testes do QuackOS

0. Regra de ouro dos testes

Cada teste deve responder sim ou n√£o.
Se exigir interpreta√ß√£o humana, est√° errado.


---

1. Testes de boot

1.1 Boot m√≠nimo

Objetivo: provar que o sistema nasce corretamente.

Verificar:

Bootloader √© carregado pela BIOS

Transi√ß√£o real ‚Üí protected ‚Üí long mode ocorre

Pagina√ß√£o ativa

Controle chega em qkern_main()


Teste pr√°tico:

hlt

Se a m√°quina parar silenciosamente, passou.


---

1.2 Endere√ßo correto do kernel

Objetivo: confirmar layout de mem√≥ria.

Escrever valor conhecido em:


0xFFFFFFFF80000000

Ler de volta


Resultado esperado:

valor id√™ntico



---

2. Testes de CPU e modo longo

2.1 Instru√ß√µes obrigat√≥rias

Objetivo: confirmar ambiente x86-64 real.

Testar:

registradores de 64 bits

SSE2 funcional


Exemplo:

uint64_t a = 0xDEADBEEFCAFEBABE;

Se compila, executa e preserva valor: ok.


---

2.2 Syscall funcional

Objetivo: confirmar transi√ß√£o user ‚Üí kernel.

Teste:

userland chama syscall vazia

kernel retorna valor conhecido


Resultado:

retorno == 42


---

3. Testes de mem√≥ria

3.1 Aloca√ß√£o b√°sica

Objetivo: provar que o gerenciador funciona.

alocar

escrever

ler

liberar


Sem page fault: passou.


---

3.2 Isolamento user/kernel

Objetivo: seguran√ßa m√≠nima.

user tenta acessar endere√ßo do QKern


Resultado esperado:

page fault

processo morto



---

4. Testes de syscalls

4.1 Tabela de syscalls

Objetivo: ABI est√°vel.

Chamar syscall inexistente


Resultado:

erro consistente (-1)



---

4.2 Argumentos inv√°lidos

Objetivo: robustez.

passar ponteiro inv√°lido


Resultado:

erro

kernel vivo



---

5. Sistema de arquivos (QFS)

5.1 Arquivos reais

Objetivo: leitura e escrita.

criar arquivo

escrever texto

ler de volta


Resultado:

conte√∫do id√™ntico



---

5.2 Pseudo-arquivos

Objetivo: ‚Äútudo √© arquivo‚Äù funcionando.

ler /proc/mem

escrever em /dev/qfb0


Resultado:

dados coerentes

a√ß√£o vis√≠vel



---

6. Processos e init

6.1 Processo init

Objetivo: userspace vivo.

QKern lan√ßa /sis/init


Resultado:

PID 1 ativo

sistema n√£o entra em loop



---

6.2 Cria√ß√£o de processos

Objetivo: multitarefa m√≠nima.

init lan√ßa /bin/quacksh


Resultado:

shell funcional



---

7. Drivers b√°sicos

7.1 Teclado

Objetivo: entrada funcionando.

pressionar tecla


Resultado:

evento recebido



---

7.2 Timer

Objetivo: tempo confi√°vel.

comparar ticks


Resultado:

monot√¥nico

sem drift grosseiro



---

8. QGUI e framebuffer

8.1 Framebuffer

Objetivo: pixels reais.

desenhar pixel

desenhar ret√¢ngulo


Resultado:

aparece na tela



---

8.2 qgui-serv

Objetivo: servidor gr√°fico vivo.

iniciar servi√ßo


Resultado:

tela limpa

sem crash



---

8.3 Janela

Objetivo: composi√ß√£o.

criar janela


Resultado:

borda

t√≠tulo

fundo



---

9. Eventos gr√°ficos

9.1 Teclado no QGUI

Objetivo: cadeia completa de eventos.

Fluxo:

teclado ‚Üí kernel ‚Üí qgui-serv ‚Üí app

Resultado:

app recebe tecla correta



---

9.2 Mouse

Objetivo: intera√ß√£o.

mover mouse

clicar


Resultado:

evento correto

coordenadas v√°lidas



---

10. Primeiro app gr√°fico (QCalc)

10.1 Execu√ß√£o

Objetivo: apps userland gr√°ficos.

executar QCalc


Resultado:

janela abre

n√£o trava



---

10.2 Entrada

Objetivo: loop de eventos.

digitar n√∫meros


Resultado:

app responde



---

11. Tema

11.1 Tema como arquivo

Objetivo: identidade do sistema.

editar arquivo .qt


Resultado:

interface muda sem recompilar



---

12. Testes de estabilidade

12.1 Long run

Objetivo: vazamentos e travamentos.

deixar sistema ligado horas


Resultado:

sem degrada√ß√£o vis√≠vel



---

12.2 Stress leve

Objetivo: robustez.

abrir v√°rias janelas

criar v√°rios processos


Resultado:

sistema permanece responsivo



---

13. Teste de fidelidade ao projeto

Esse √© especial.

Checklist final:

nomes em portugu√™s?

c√≥digo curto?

camadas separadas?

tudo ainda √© arquivo?

roda em hardware antigo?


Se algum ‚Äún√£o‚Äù: regress√£o conceitual.


---

14. Ferramentas de teste recomendadas

QEMU (principal)

Bochs (debug)

Hardware real antigo (teste final)

Logs em /sis/log



---

Resumo brutal

Se:

boota

isola mem√≥ria

syscalls funcionam

arquivos fazem coisas

pixels aparecem

eventos fluem

apps vivem

e o c√≥digo ainda √© simples


Ent√£o o QuackOS est√° certo ü¶Ü‚úîÔ∏è

Se quiser, posso:

transformar isso num TEST_PLAN.md

criar testes automatizados iniciais

ou definir um crit√©rio oficial de ‚Äúbuild est√°vel‚Äù


Agora o pato n√£o s√≥ anda. Ele passa por inspe√ß√£o t√©cnica üß™ü¶Ü