Excelente. Agora entramos na parte mais delicada e mais bonita do Caminho B:
dar nomes humanos ao diÃ¡logo entre programas e o nÃºcleo ğŸ§ ğŸ“

Aqui nÃ£o estamos â€œtraduzindo syscallsâ€.
Estamos rebatizando intenÃ§Ãµes.


---

QFS â€¢ Syscalls em PortuguÃªs

A linguagem Ã­ntima entre o programa e o nÃºcleo


---

1. PrincÃ­pio linguÃ­stico das syscalls do Caminho B

Regras que guiam tudo:

1. Verbo no infinitivo


2. AÃ§Ã£o concreta ou humana


3. Sem siglas


4. Sem inglÃªs aparente


5. Nome revela intenÃ§Ã£o, nÃ£o implementaÃ§Ã£o



O nome deve responder:

> â€œO que o programa quer do sistema?â€




---

2. Categorias fundamentais de syscalls

Vamos organizar por intenÃ§Ã£o, nÃ£o por tradiÃ§Ã£o POSIX.


---

3. ExistÃªncia e vida dos processos

POSIX	QFS

fork	duplicar
exec	vestir
exit	partir
kill	encerrar
wait	esperar
getpid	quem_sou
getppid	quem_me_criou


Exemplos conceituais:

duplicar() â†’ cria outro â€œeuâ€

vestir("/coisas/listar") â†’ troca de identidade

partir(codigo) â†’ saÃ­da consciente



---

4. MemÃ³ria como espaÃ§o mental ğŸ§ 

POSIX	QFS

mmap	lembrar
munmap	esquecer
brk	esticar_memoria
mprotect	proteger_memoria


MemÃ³ria nÃ£o Ã© nÃºmero. Ã‰ lembranÃ§a.


---

5. Arquivos e caminhos

POSIX	QFS

open	abrir
close	fechar
read	ler
write	escrever
lseek	procurar
stat	observar
unlink	apagar


Aqui quase nÃ£o muda, porque UNIX jÃ¡ acertou.

Mas:

stat vira observar

unlink vira apagar (sem eufemismo)



---

6. ComunicaÃ§Ã£o e I/O

POSIX	QFS

pipe	sussurrar
dup	copiar_voz
dup2	redirecionar_voz
ioctl	pedir_jeito
fsync	confirmar


sussurrar() cria canal Ã­ntimo

pedir_jeito() Ã© o pedido genÃ©rico ao treco



---

7. Tempo e espera â³

POSIX	QFS

sleep	cochilar
nanosleep	piscar
clock_gettime	que_horas
alarm	lembrar_depois
timer_settime	marcar


Tempo Ã© ritmo, nÃ£o contador.


---

8. UsuÃ¡rios, permissÃµes e poder

POSIX	QFS

setuid	virar
setgid	juntar
chmod	permitir
chown	transferir
umask	desconfiar


desconfiar() define limites por padrÃ£o

virar(uid) assume outra identidade



---

9. DiretÃ³rios e mundo

POSIX	QFS

chdir	ir_para
getcwd	onde_estou
mkdir	criar_lugar
rmdir	remover_lugar
mount	encaixar
umount	desencaixar


Sistema vira espaÃ§o navegÃ¡vel, nÃ£o tabela.


---

10. Sinais e eventos âš¡

POSIX	QFS

signal	avisar
sigaction	combinar_sinal
pause	congelar
select	escutar
poll	prestar_atencao


Sinais deixam de ser nÃºmeros mÃ¡gicos.
SÃ£o avisos.


---

11. Erros como estado, nÃ£o exceÃ§Ã£o

Nada de errno.

Proposta:

resultado = tentar(abrir("/coisas/x"))
se resultado.falhou:
    dizer(resultado.porque)

Syscall auxiliar:

tentar()

falhou()

porque()


Erro Ã© objeto legÃ­vel.


---

12. Syscalls proibidas (por filosofia)

VocÃª nÃ£o expÃµe:

ptrace â†’ invasivo demais

reboot â†’ deve ser escrita em /sis/recomeÃ§ar

sysctl â†’ tudo jÃ¡ Ã© arquivo



---

13. Forma da API (exemplo imaginÃ¡rio)

processo filho = duplicar();

se filho == 0:
    vestir("/coisas/listar");
    partir(0);
senao:
    esperar(filho);

Isso Ã© legÃ­vel sem manual.


---

14. Camada de compatibilidade

Internamente:

POSIX existe

ABI clÃ¡ssica funciona


Externamente:

Programador escolhe falar QFS


Como lÃ­nguas naturais:

NÃºcleo Ã© bilÃ­ngue

Interface Ã© cultural



---

15. Frase final do nÃºcleo

Se alguÃ©m perguntar:

> â€œPor que esses nomes?â€



Resposta oficial:

> Porque o sistema nÃ£o Ã© uma abstraÃ§Ã£o.
Ã‰ um lugar onde coisas acontecem.




---

Se quiser, no prÃ³ximo passo eu posso:

desenhar a tabela completa (100+ syscalls)

definir a convenÃ§Ã£o de nomes

criar um header quack.h

ou simular isso em Linux usando wrappers


Esse Ã© o ponto onde o sistema comeÃ§a a falar. ğŸ¦†ğŸ“